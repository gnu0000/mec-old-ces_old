/*--------------------------------------------------------------------------+
|                                                                           |
|       Copyright (c) 1992 by Info Tech, Inc.  All Rights Reserved.         |
|                                                                           |
|       This program module is part of DS/Shell (PC), Info Tech's           |
|       database interfaces for OS/2, a proprietary product of              |
|       Info Tech, Inc., no part of which may be reproduced or              |
|       transmitted in any form or by any means, electronic,                |
|       mechanical, or otherwise, including photocopying and recording      |
|       or in connection with any information storage or retrieval          |
|       system, without permission in writing from Info Tech, Inc.          |
|                                                                           |
+--------------------------------------------------------------------------*/


/***************************************************************************\
* ARRANGE.c - This file contains code to do window arrangment.
*
* Created by Microsoft Corporation, 1989
\***************************************************************************/

#define INCL_WIN
#include "..\include\iti.h"
#include "..\include\itiglob.h"
#include "window.h"
#include "..\include\ItiMenu.h"
#include "..\include\itierror.h"
#include "..\include\itibase.h"
#include "init.h"

#define MINMAXFIX  /* add hack to keep the min/max icons in sync with reality */

/* internal function prototypes */
static BOOL SetTilePositions(PRECTL prclArea, SHORT sNumWindows, PSWP pswpWindows);
static SHORT CeilSquareRoot(USHORT us);
static BOOL SetCascadePositions(PRECTL prclArea, SHORT sNumWindows, PSWP pswpWindows);
static BOOL SetCascadeParams(PRECTL prclArea, SHORT *pxEdge, SHORT *pyEdge,
                      SHORT *pxDelta, SHORT *pyDelta, SHORT *cMaxWnd);

/* internal constants */
#define CASC_EDGE_NUM       2
#define CASC_EDGE_DENOM     3

/* local constants */
#define ICON_PARK_NUM       5
#define ICON_PARK_DENOM     3
#define CLASS_NAME_LENGTH   8

/***************************************************************************\
* ArrangeWindowPositions
*
* This function sets positions for arranging windows nicely in a rectangle.
* The hwnd field of each SWP structure should be set by the user, either
* before or after calling this function.  The function sets all other
* fields.  The SWP array can then be passed to WinSetMultWindowPos() to do
* the physical arrangement.  There are two arrangement styles available,
* AW_TILED and AW_CASCADED.
*
* AW_TILED:
*
* The tiles are generated by rows, top left (first) to bottom right (last).
* Each row has the same number of tiles.  The number of tiles in each
* column will differ by at most one, with each column containing one fewer
* tile to the left of the other columns.
*
* AW_CASCADED:
*
* The windows are generated bottom right (first) to top left (last).
*
* Parameters:
*   prclArea:    rectangle to contain the tiled windows
*   sNumWindows:   number of windows to tile
*   pswpWindows:   array of SWP structures, one for each tile window
*   usStyle: the style to arrange the windows
\***************************************************************************/

static BOOL ArrangeWindowPositions (PRECTL prclArea,
                                    SHORT  sNumWindows,  
                                    PSWP   pswpWindows,
                                    USHORT usStyle)
   {
   /* check validity of input rectangle */
   if ((prclArea->xRight - prclArea->xLeft < 1) ||
       (prclArea->yTop - prclArea->yBottom < 1))
      {
      return FALSE;
      }

   /* set window positions */
   switch (usStyle)
      {
      case AW_TILED:
         return SetTilePositions (prclArea, sNumWindows, pswpWindows);

      case AW_CASCADED:
         return SetCascadePositions (prclArea, sNumWindows, pswpWindows);

      default:
         return FALSE;
      }
   }


/***************************************************************************\
* SetTilePositions
*
* This function sets positions for tiling windows in a rectangle.
*
* NOTE:
*   There are a few subtleties to this code:
*
*   The algorithm lays tiles in a modified NxN grid.  It can be shown
*   that any positive number of tiles can be laid out in such a grid of
*   N columns so that each column has at least N-2 tiles and no column
*   has more than one tile more than any other.  Proof left to the
*   interested reader.
*
*   The tiles coordinates are not generated by stepping over a fixed
*   interval since this will not usually fill the rectangle completely.
*   Thus the offset at each step is calculated from the previous tile
*   to the correct fractional position within the whole rectangle.
*
*   Since the last "row" of tiles may not have any members in the beginning
*   columns, these tiles are addressed differently in the SWP array to
*   account for the "missing" tiles.
*
* Parameters:
*   prclArea:        rectangle to contain the tiled windows
*   sNumWindows:        number of windows to tile the rectangle with
*   pswpWindows:        array of SWP structures, one for each tile window
\***************************************************************************/

static BOOL SetTilePositions (PRECTL   prclArea,
                              SHORT    sNumWindows,
                              PSWP     pswpWindows)
   {
   register SHORT usRoot;
   register SHORT cExtras;
   SHORT iChange;
   SHORT cDiff;
   SHORT x, y, cx, cy;
   SHORT iRow, iCol;

   /* get grid dimensions */
   usRoot = CeilSquareRoot (sNumWindows);
   cExtras = usRoot * usRoot - sNumWindows;

   /* find column where number of rows increases and find initial
      difference of rows versus columns */
   if (cExtras >= usRoot)
      {
      iChange = cExtras - usRoot;
      cDiff = 2;
      }
   else
      {
      iChange = cExtras;
      cDiff = 1;
      }

   /* assign x coordinates */
   x = (SHORT)prclArea->xLeft;
   cx = 0;
   for (iCol = 0; iCol < usRoot; iCol++)
      {
      x += cx - pglobals->alSysValues [SV_CXBORDER];
      cx = ((SHORT) prclArea->xLeft) +
           (((SHORT) (prclArea->xRight - prclArea->xLeft)) *
            (iCol + 1)) / usRoot - x +
            (SHORT) pglobals->alSysValues [SV_CXBORDER];

      for (iRow = 0; iRow < usRoot - cDiff; iRow++)
         {
         pswpWindows [iRow * usRoot + iCol].x = x;
         pswpWindows [iRow * usRoot + iCol].cx = cx;
         pswpWindows [iRow * usRoot + iCol].fs = SWP_SIZE | SWP_MOVE;
         }

      /* assign "extra" row */
      if (iCol >= iChange)
         {
         pswpWindows [iRow * usRoot + iCol - iChange].x = x;
         pswpWindows [iRow * usRoot + iCol - iChange].cx = cx;
         pswpWindows [iRow * usRoot + iCol - iChange].fs = SWP_SIZE | SWP_MOVE;
         }
      }

   /* assign y coordinates, columns without extra row */
   y = (SHORT) prclArea->yBottom;
   cy = 0;
   for (iRow = usRoot - cDiff - 1; iRow >= 0; iRow--)
      {
      y += cy - pglobals->alSysValues [SV_CYBORDER];
      cy = ((SHORT) prclArea->yBottom) +
           (((SHORT) (prclArea->yTop - prclArea->yBottom)) *
           (usRoot - cDiff - iRow)) / (usRoot - cDiff) - y +
            (SHORT) pglobals->alSysValues [SV_CYBORDER];

      for (iCol = 0; iCol < iChange; iCol++)
         {
         pswpWindows [iRow * usRoot + iCol].y = y;
         pswpWindows [iRow * usRoot + iCol].cy = cy;
         }
      }

   /* assign y coordinates, columns with extra row */
   /* do last row first (different offsets) */
   y = (SHORT) prclArea->yBottom -
       (SHORT) pglobals->alSysValues [SV_CYBORDER];
   cy = ((SHORT) (prclArea->yTop - prclArea->yBottom)) /
                 (usRoot - cDiff + 1) +
                  2 * (SHORT) pglobals->alSysValues [SV_CYBORDER];

   for (iCol = iChange; iCol < usRoot; iCol++)
      {
      pswpWindows [usRoot * (usRoot - cDiff) + iCol - iChange].y = y;
      pswpWindows [usRoot * (usRoot - cDiff) + iCol - iChange].cy = cy;
      }
   for (iRow = usRoot - cDiff - 1; iRow >= 0; iRow--)
      {
      y += cy - pglobals->alSysValues [SV_CYBORDER];
      cy = ((SHORT) (prclArea->yBottom)) +
              (((SHORT) (prclArea->yTop - prclArea->yBottom)) *
              (usRoot - cDiff - iRow + 1)) / (usRoot - cDiff + 1) -
              y + (SHORT) pglobals->alSysValues [SV_CYBORDER];

      for (iCol = iChange; iCol < usRoot; iCol++)
         {
         pswpWindows [iRow * usRoot + iCol].y = y;
         pswpWindows [iRow * usRoot + iCol].cy = cy;
         }
      }

   return TRUE;
   }


/***************************************************************************\
* CeilSquareRoot
*
* This function returns the smallest integer greater or equal to the square
* root of an unsigned 16 bit integer.
*
* Parameter:
*   us: value to take the root of
\***************************************************************************/

static SHORT CeilSquareRoot (register USHORT us)
   {
   register SHORT i;

   /* prevent overflow of large numbers */
   if (us > 0xFE * 0xFE)
       return 0xFF;

   /* iterate up past root */
   for (i = 0; i*i < (SHORT) us; i++)
       ;
   return i;
   }


/***************************************************************************\
* SetCascadePositions
*
* This function sets positions for cascading windows in a rectangle.
*
* Parameters:
*   prclArea:        rectangle to contain the cascaded windows
*   sNumWindows:        number of windows to cascade
*   pswpWindows:        array of SWP structures, one for each cascaded window
\***************************************************************************/

static BOOL SetCascadePositions (PRECTL   prclArea,
                                 SHORT    sNumWindows,
                                 PSWP     pswpWindows)
   {
   SHORT xEdge, yEdge;
   SHORT xDelta, yDelta;
   SHORT cMaxWnd;
   register SHORT x, y;
   SHORT i, j;
   RECTL rc;

   /* set cascade parameters */
   rc.xLeft = prclArea->xLeft - pglobals->alSysValues [SV_CXBORDER];
   rc.xRight = prclArea->xRight + pglobals->alSysValues [SV_CYBORDER];
   rc.yBottom = prclArea->yBottom - pglobals->alSysValues [SV_CYBORDER];
   rc.yTop = prclArea->yTop + pglobals->alSysValues [SV_CYBORDER];

   if (!SetCascadeParams (&rc, &xEdge, &yEdge, &xDelta, &yDelta, &cMaxWnd))
      {
      return FALSE;
      }

   if (sNumWindows <= cMaxWnd)
      {
      /* only one run needed; move to top left corner */
      x = (SHORT) rc.xLeft;
      y = (SHORT) rc.yTop - yEdge;
      for (i = sNumWindows - 1; i >= 0; i--)
         {
         pswpWindows [i].x = x;
         pswpWindows [i].y = y;
         pswpWindows [i].cx = xEdge;
         pswpWindows [i].cy = yEdge;
         pswpWindows [i].fs = SWP_SIZE | SWP_MOVE;
         x += xDelta;
         y -= yDelta;
         }
      }
   else
      {

      /* multiple runs necessary; start at bottom right, iterate up to
         top left */

      i = 0;

      while (i < sNumWindows)
         {
         /* even run */
         x = ((SHORT) rc.xLeft) + (cMaxWnd-1) * xDelta;
         y = ((SHORT) rc.yTop) - yEdge - (cMaxWnd-1) * yDelta;

         for (j = 0; j < cMaxWnd; j++)
            {
            pswpWindows [i].x = x;
            pswpWindows [i].y = y;
            pswpWindows [i].cx = xEdge;
            pswpWindows [i].cy = yEdge;
            pswpWindows [i].fs = SWP_SIZE | SWP_MOVE;
            x -= xDelta;
            y += yDelta;
            if (++i >= sNumWindows)
               break;
            }

         if (i >= sNumWindows)
             break;

         /* odd run, offset by half delta y, one and one half delta x */
         x = ((SHORT) rc.xLeft) + (cMaxWnd-1) * xDelta + xDelta/2;
         y = ((SHORT) rc.yTop) - yEdge - (cMaxWnd-1) * yDelta + yDelta/2;

         for (j = 0; j < cMaxWnd - 1; j++)
            {
            pswpWindows [i].x = x;
            pswpWindows [i].y = y;
            pswpWindows [i].cx = xEdge;
            pswpWindows [i].cy = yEdge;
            pswpWindows [i].fs = SWP_SIZE | SWP_MOVE;
            x -= xDelta;
            y += yDelta;
            if (++i >= sNumWindows)
               break;
            }
         }
      }

   return TRUE;
   }


/***************************************************************************\
* SetCascadeParams
*
* This function sets parameters for cascading windows.        The window edges
* are based on a fraction CASC_EDGE_NUM/CASC_EDGE_DENOM of the rectangle.
* The x delta is four system font characters across, the y delta is two
* system lines high.
*
* Parameters:
*   prclArea:        rectangle to contain the windows
*   pxEdge:        width of the cascaded windows
*   pyEdge:        height of the cascaded windows
*   pxDelta:        x cascade offset
*   pyDelta:        y cascade offset
*   pcMaxWnd:        maximum number of windows in a cascade
\***************************************************************************/

static BOOL SetCascadeParams (PRECTL   prclArea,
                              SHORT    *pxEdge,
                              SHORT    *pyEdge,
                              SHORT    *pxDelta,
                              SHORT    *pyDelta,
                              SHORT    *pcMaxWnd)
   {
   register SHORT xEdge, yEdge;
   SHORT xDelta, yDelta;
   SHORT cMaxWnd;

   /* get x and y deltas from system values */
   xDelta = LOUSHORT (pglobals->alSysValues [SV_CXSIZEBORDER]) +
            LOUSHORT (pglobals->alSysValues [SV_CXMINMAXBUTTON]) / 2 + 2;
   yDelta = LOUSHORT (pglobals->alSysValues [SV_CYSIZEBORDER]) +
            LOUSHORT (pglobals->alSysValues [SV_CYTITLEBAR])
            - (SHORT) pglobals->alSysValues [SV_CYBORDER];

   /* get initial cut at yEdge using fraction */
   yEdge = (((SHORT) (prclArea->yTop - prclArea->yBottom)) * CASC_EDGE_NUM) /
           CASC_EDGE_DENOM;

   /* determine maximum number of deltas used per run */
   cMaxWnd = (((SHORT)(prclArea->yTop - prclArea->yBottom)) - yEdge) / yDelta;

   /* set x and y edges so full cascade will fill rectangle completely */
   xEdge = ((SHORT) (prclArea->xRight - prclArea->xLeft)) -
                     xDelta/2 - cMaxWnd * xDelta;
   yEdge = ((SHORT) (prclArea->yTop - prclArea->yBottom)) - cMaxWnd * yDelta;

   /* check that values are reasonable */
   if (cMaxWnd < 1 || xEdge < 1 || yEdge < 1)
      {
      return FALSE;
      }

   *pxEdge = xEdge;
   *pyEdge = yEdge;
   *pxDelta = xDelta;
   *pyDelta = yDelta;

   /* return cMaxWnd as the maximum number of windows in a cascade */
   *pcMaxWnd = cMaxWnd + 1;

   return TRUE;
   }





/*
 * ItiMenuArrangeWindows arranges the immediate child windows of
 * hwndApplication, according to the value of usStyle.
 *
 * Parameters: hwndApplication:  The parent of the windows to be arranged.
 *
 *             usStyle:          Tells how to arrange the windows. Valid
 *                               values are:
 *
 *                               AW_TILED       Arrange the windows in a
 *                                              tiled manner.
 *
 *                               AW_CASCADED    Arrange the windows in a
 *                                              cascaded manner.
 *
 * Return Value:
 *   TRUE if successful
 *   FALSE otherwise
 *
 * Comments:
 */


BOOL EXPORT ItiMenuArrangeWindows (HWND hwndApplication, USHORT usStyle)
   {
   USHORT   usNumWindows;
   RECTL    rcl;
   PSWP     pswp;

   pswp = ItiMenuGetChildSwp (hwndApplication, &usNumWindows, TRUE);

   if (usNumWindows == 0)
      return TRUE;

   if (pswp == NULL)
      return FALSE;

   WinQueryWindowRect (hwndApplication, &rcl);

   /* set window positions */
   if (!ArrangeWindowPositions (&rcl, usNumWindows, pswp, usStyle))
      {
      ItiMemFreeSeg (pswp);

      return FALSE;
      }

   /* rearrange the windows */
   WinSetMultWindowPos (NULL, pswp, usNumWindows);

   ItiMemFreeSeg (pswp);

   return TRUE;
   }

